using UnityEngine;
using System.Collections;
using DG.Tweening;

public class BottomBarIndicator : MonoBehaviour
{
    [SerializeField] private RectTransform _indicator;
    [Range(0.0f, 2f)]
    [SerializeField] private float _scaleAnimfactor = 0.9f;
    [SerializeField] private float _moveDuration = 0.25f;

    private Coroutine _moveCoroutine;

    public void MoveTo(RectTransform target)
    {
        //if (_moveCoroutine != null)
          //  StopCoroutine(_moveCoroutine);

        //_moveCoroutine = StartCoroutine(MoveIndicator(target));
        _indicator.DOMoveX(target.position.x, _moveDuration);
        _indicator.DOScaleY(_scaleAnimfactor, _moveDuration / 2).OnComplete(() =>
        {
            _indicator.DOScale(Vector3.one, _moveDuration / 2);
        });
    }

    IEnumerator MoveIndicator(RectTransform target)
    {
        Vector3 startPos = _indicator.position;
        Vector3 endPos = new Vector3(
            target.position.x,
            _indicator.position.y,
            _indicator.position.z
        );

        float elapsed = 0f;

        while (elapsed < _moveDuration)
        {
            elapsed += Time.deltaTime;
            float t = elapsed / _moveDuration;

            _indicator.position = Vector3.Lerp(startPos, endPos, t);
            yield return null;
        }

        _indicator.position = endPos;
    }
}
using options;
using UnityEngine;
using UnityEngine.SceneManagement;

public class GameInitializer : MonoBehaviour
{
    [SerializeField] private LevelController _levelController;
    private int _currentLevelIndex;

    private void Start()
    {
        int lastCompletedLevel = Options.GetInt("Levels.lastLevel", 0);
        _currentLevelIndex = lastCompletedLevel + 1;

        Debug.Log($"Завантажую рівень: {_currentLevelIndex}");

        TextAsset levelFile = Resources.Load<TextAsset>($"Levels/level_{_currentLevelIndex}");
        if (levelFile != null)
        {
            var levelModel = LevelLoader.LoadFromJSON(levelFile.text);
            _levelController.Initialize(levelModel);

            // 3. Підписуємося на перемогу
            _levelController.OnLevelCompleted += OnLevelWon;
        }
        else
        {
            Debug.LogError("Не знайдено жодного файлу рівня в Resources/Levels/!");
        }
    }


    private void OnLevelWon()
    {
        Debug.Log($"Зберігаємо прогрес: пройдено рівень {_currentLevelIndex}");

        Options.SetInt("Levels.lastLevel", _currentLevelIndex);
        Options.Save();

        SceneManager.LoadScene("MainMenu");


    }
}
using System;
using System.IO;
using System.Xml;
using UnityEngine;

namespace options
{
    /// <summary>
    /// Статична система Options для data-driven роботи з параметрами через XML.
    /// Використовує dot-notation для доступу до атрибутів: "section.subsection.attribute"
    /// </summary>
    public static class Options
    {
        private static XmlDocument xmlDoc;
        private static string filePath;
        private static bool isDirty = false;
        private static bool isInitialized = false;

        private const string ROOT_NODE_NAME = "Options";
        private const string DEFAULT_FILENAME = "options.xml";

        /// <summary>
        /// Ініціалізує систему Options. Викликається автоматично при першому зверненні.
        /// </summary>
        private static void Initialize()
        {
            if (isInitialized) return;


            filePath = Path.Combine(Application.persistentDataPath, DEFAULT_FILENAME);//тут можна змінити шлях до файлу
            xmlDoc = new XmlDocument();

            if (File.Exists(filePath))
            {
                try
                {
                    xmlDoc.Load(filePath);
                    Console.WriteLine($"[Options] Завантажено з {filePath}");
                }
                catch (Exception e)
                {
                    Console.WriteLine($"[Options] Помилка завантаження XML: {e.Message}. Створюється новий файл.");
                    CreateNewDocument();
                }
            }
            else
            {
                CreateNewDocument();
            }

            isInitialized = true;
        }

        /// <summary>
        /// Створює новий XML-документ з кореневим елементом
        /// </summary>
        private static void CreateNewDocument()
        {
            xmlDoc = new XmlDocument();
            XmlDeclaration declaration = xmlDoc.CreateXmlDeclaration("1.0", "UTF-8", null);
            xmlDoc.AppendChild(declaration);

            XmlElement root = xmlDoc.CreateElement(ROOT_NODE_NAME);
            xmlDoc.AppendChild(root);

            isDirty = true;
        }

        /// <summary>
        /// Знаходить або створює XML-ноду за шляхом (без останнього сегмента - атрибута)
        /// </summary>
        private static XmlElement GetOrCreateNode(string path, bool createIfMissing)
        {
            if (!isInitialized) Initialize();

            string[] segments = path.Split('.');
            if (segments.Length < 2)
            {
                Console.WriteLine($"[Options] Некоректний шлях: {path}. Очікується формат 'node.attribute'");
                return null;
            }

            XmlElement current = xmlDoc.DocumentElement;

            // Проходимо всі сегменти крім останнього (останній - це атрибут)
            for (int i = 0; i < segments.Length - 1; i++)
            {
                string segment = segments[i];
                XmlElement child = current[segment];

                if (child == null)
                {
                    if (!createIfMissing) return null;

                    child = xmlDoc.CreateElement(segment);
                    current.AppendChild(child);
                    isDirty = true;
                }

                current = child;
            }

            return current;
        }

        /// <summary>
        /// Отримує ім'я атрибута з повного шляху
        /// </summary>
        private static string GetAttributeName(string path)
        {
            string[] segments = path.Split('.');
            return segments[segments.Length - 1];
        }

        // ===== GET методи =====

        /// <summary>
        /// Отримує int значення за ключем
        /// </summary>
        public static int GetInt(string key, int defaultValue = 0)
        {
            string value = GetString(key, null);
            return value != null && int.TryParse(value, out int result) ? result : defaultValue;
        }

        /// <summary>
        /// Отримує float значення за ключем
        /// </summary>
        public static float GetFloat(string key, float defaultValue = 0f)
        {
            string value = GetString(key, null);
            return value != null && float.TryParse(value, System.Globalization.NumberStyles.Float,
                System.Globalization.CultureInfo.InvariantCulture, out float result) ? result : defaultValue;
        }

        /// <summary>
        /// Отримує bool значення за ключем
        /// </summary>
        public static bool GetBool(string key, bool defaultValue = false)
        {
            string value = GetString(key, null);
            if (value == null) return defaultValue;

            value = value.ToLower();
            if (value == "true" || value == "1") return true;
            if (value == "false" || value == "0") return false;

            return defaultValue;
        }

        /// <summary>
        /// Отримує string значення за ключем
        /// </summary>
        public static string GetString(string key, string defaultValue = "")
        {
            XmlElement node = GetOrCreateNode(key, false);
            if (node == null) return defaultValue;

            string attrName = GetAttributeName(key);
            if (!node.HasAttribute(attrName)) return defaultValue;

            return node.GetAttribute(attrName);
        }

        // ===== SET методи =====

        /// <summary>
        /// Записує int значення за ключем
        /// </summary>
        public static void SetInt(string key, int value)
        {
            SetString(key, value.ToString());
        }

        /// <summary>
        /// Записує float значення за ключем
        /// </summary>
        public static void SetFloat(string key, float value)
        {
            SetString(key, value.ToString(System.Globalization.CultureInfo.InvariantCulture));
        }

        /// <summary>
        /// Записує bool значення за ключем
        /// </summary>
        public static void SetBool(string key, bool value)
        {
            SetString(key, value ? "true" : "false");
        }

        /// <summary>
        /// Записує string значення за ключем
        /// </summary>
        public static void SetString(string key, string value)
        {
            XmlElement node = GetOrCreateNode(key, true);
            if (node == null) return;

            string attrName = GetAttributeName(key);
            string currentValue = node.HasAttribute(attrName) ? node.GetAttribute(attrName) : null;

            if (currentValue != value)
            {
                node.SetAttribute(attrName, value);
                isDirty = true;
            }
        }

        // ===== Збереження та керування =====

        /// <summary>
        /// Зберігає XML у файл, якщо були зміни
        /// </summary>
        public static void Save()
        {
            if (!isInitialized) Initialize();
            if (!isDirty) return;

            try
            {
                Directory.CreateDirectory(Path.GetDirectoryName(filePath));
                xmlDoc.Save(filePath);
                isDirty = false;
                Console.WriteLine($"[Options] Збережено у {filePath}");
            }
            catch (Exception e)
            {
                Console.WriteLine($"[Options] Помилка збереження: {e.Message}");
            }
        }

        /// <summary>
        /// Примусово перезавантажує XML з файлу
        /// </summary>
        public static void Reload()
        {
            isInitialized = false;
            isDirty = false;
            Initialize();
        }

        /// <summary>
        /// Перевіряє, чи є незбережені зміни
        /// </summary>
        public static bool HasUnsavedChanges()
        {
            return isDirty;
        }

        /// <summary>
        /// Отримує повний шлях до файлу options.xml
        /// </summary>
        public static string GetFilePath()
        {
            if (!isInitialized) Initialize();
            return filePath;
        }

        /// <summary>
        /// Видаляє атрибут або ноду за ключем
        /// </summary>
        public static void Delete(string key)
        {
            XmlElement node = GetOrCreateNode(key, false);
            if (node == null) return;

            string attrName = GetAttributeName(key);
            if (node.HasAttribute(attrName))
            {
                node.RemoveAttribute(attrName);
                isDirty = true;
            }
        }

        /// <summary>
        /// Перевіряє, чи існує ключ
        /// </summary>
        public static bool HasKey(string key)
        {
            XmlElement node = GetOrCreateNode(key, false);
            if (node == null) return false;

            string attrName = GetAttributeName(key);
            return node.HasAttribute(attrName);
        }
    }
}
using UnityEngine;
using options;

public class SaveManager : MonoBehaviour
{
    private void Awake()
    {
        DontDestroyOnLoad(this.gameObject);
    }

    // Вызывается, когда игра закрывается
    private void OnApplicationQuit()
    {
        if (Options.HasUnsavedChanges())
        {
            Options.Save();
            Debug.Log("Настройки сохранены при выходе.");
        }
    }

    // Вызывается на мобилках, когда приложение сворачивается (pause)
    private void OnApplicationPause(bool pauseStatus)
    {
        if (pauseStatus && Options.HasUnsavedChanges())
        {
            Options.Save();
        }
    }
}
using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;

[AddComponentMenu("UI/Effects/Multi Gradient")]
public class UIGradientMulti : BaseMeshEffect
{
    [Tooltip("Нажми на полоску, чтобы открыть редактор градиента")]
    public Gradient gradient = new Gradient(); // Встроенный класс Unity для списка цветов

    [Range(0f, 360f)]
    public float angle = 0f;

    public override void ModifyMesh(VertexHelper vh)
    {
        if (!IsActive()) return;

        List<UIVertex> vertexList = new List<UIVertex>();
        vh.GetUIVertexStream(vertexList);
        int count = vertexList.Count;

        if (count == 0) return;

        // --- 1. Математика поворота (как в прошлом примере) ---
        float rad = -angle * Mathf.Deg2Rad;
        float cos = Mathf.Cos(rad);
        float sin = Mathf.Sin(rad);

        // --- 2. Находим границы (Min/Max) в повернутой системе ---
        float min = float.MaxValue;
        float max = float.MinValue;

        for (int i = 0; i < count; i++)
        {
            Vector3 pos = vertexList[i].position;
            // Проецируем точку на ось градиента
            float yRotated = pos.x * sin + pos.y * cos;

            if (yRotated > max) max = yRotated;
            if (yRotated < min) min = yRotated;
        }

        float uiHeight = max - min;
        if (uiHeight == 0) return;

        // --- 3. Применяем цвета из Gradient ---
        for (int i = 0; i < count; i++)
        {
            UIVertex uiVertex = vertexList[i];

            // Снова вычисляем повернутую позицию
            float yRotated = uiVertex.position.x * sin + uiVertex.position.y * cos;

            // Нормализуем t от 0 до 1
            float t = (yRotated - min) / uiHeight;

            // ГЛАВНОЕ ИЗМЕНЕНИЕ:
            // Вместо Lerp берем цвет из градиента в точке t.
            // Также умножаем на исходный цвет вершины (чтобы работала прозрачность самого Image)
            uiVertex.color = gradient.Evaluate(t) * uiVertex.color;

            vertexList[i] = uiVertex;
        }

        vh.Clear();
        vh.AddUIVertexTriangleStream(vertexList);
    }
}
using System;
using System.Collections.Generic;
using UnityEngine;

public class LevelController : MonoBehaviour
{
    [Header("Посилання")]
    [SerializeField] private LevelView _levelView;
    [SerializeField] private GridView _gridView;
    [SerializeField] private InputHandler _inputHandler;

    [Header("Камера")]
    [SerializeField] private Camera _camera; // Перетягни сюди Main Camera
    [SerializeField] private float _padding = 1.5f; // Відступ від країв екрану

    private LevelModel _currentLevel;

    public event Action OnLevelCompleted;

    private void OnEnable()
    {
        if (_inputHandler != null)
        {
            _inputHandler.OnGridClick += OnGridClicked;
        }
    }

    private void OnDisable()
    {
        if (_inputHandler != null)
        {
            _inputHandler.OnGridClick -= OnGridClicked;
        }
    }


    public void Initialize(LevelModel levelModel)
    {
        _currentLevel = levelModel;
        _gridView.Init(levelModel.Height, levelModel.Width);
        if (levelModel != null)
        {
            _levelView.RenderLevel(levelModel);
            PrintGridToConsole(levelModel);
        }
        FitCameraToGrid(levelModel);
    }

    private void FitCameraToGrid(LevelModel model)
    {
        if (_camera == null || _gridView == null) return;

        float cellSize = _gridView.CellSize;
        Vector3 startPos = _gridView.StartPosition;

        // --- 1. Знаходимо центр сітки ---
        // Ширина сітки в одиницях світу
        float totalWidth = model.Width * cellSize;
        // Висота сітки (Rows)
        float totalHeight = model.Height * cellSize;

        // Центр X: від старту зміщуємося вправо на половину ширини
        // (Мінус половина клітинки, бо координата об'єкта - це його центр, а не край,
        // але для простоти беремо (cols-1))
        float centerX = startPos.x + (model.Width - 1) * cellSize / 2.0f;

        // Центр Y: від старту зміщуємося ВНИЗ (тому мінус)
        // У твоєму GridView (Source 289) Y йде як: start.y - i * size
        float centerY = startPos.y - (model.Height - 1) * cellSize / 2.0f;

        // Ставимо камеру в центр
        _camera.transform.position = new Vector3(centerX, centerY, _camera.transform.position.z);

        // --- 2. Розраховуємо Зум (Orthographic Size) ---
        // OrthographicSize = половина висоти екрану, яку бачить камера.

        // Варіант А: Підганяємо по висоті (Height / 2 + відступи)
        float targetHeight = (totalHeight / 2.0f) + _padding;

        // Варіант Б: Підганяємо по ширині.
        // Оскільки камера налаштовується через висоту, конвертуємо ширину у висоту через Aspect Ratio.
        float aspect = _camera.aspect; // Ширина / Висота
        float targetWidth = ((totalWidth / 2.0f) + _padding) / aspect;

        // Вибираємо більше значення, щоб сітка точно влізла і по ширині, і по висоті
        _camera.orthographicSize = Mathf.Max(targetHeight, targetWidth);
    }

    private void OnGridClicked(GridCoordinate coord)
    {
        HandleCellClick(coord.Column, coord.Row);
        print($"Clicked Cell: X={coord.Column}, Y={coord.Row}");
    }

    private void HandleCellClick(int x, int y)
    {
        int arrowId = _currentLevel.GetArrowIdAt(x, y); // y, x (Row, Col)

        if (arrowId <= 0) return;

        if (_currentLevel.CanArrowFlyAway(arrowId))
        {
            Debug.Log($"Стрілка {arrowId} полетіла!");
            _currentLevel.RemoveArrow(arrowId);
            _levelView.RemoveVisualArrow(arrowId);

            CheckLevelEnd();
        }
        else
        {
            Debug.Log($"Стрілка {arrowId} заблокована!");
            // Тут можна додати анімацію трусіння
        }
    }

    private void CheckLevelEnd()
    {
        if (_currentLevel.Arrows.Count == 0)
        {
            Debug.Log("LEVEL COMPLETE!");

            // Можна вимкнути введення, щоб гравець не клікав під час екрану перемоги
            if (_inputHandler != null) _inputHandler.SetInputActive(false);

            OnLevelCompleted?.Invoke();
        }
    }

    private void PrintGridToConsole(LevelModel model)
    {
        string output = "Level Matrix:\n";

        // СТАНДАРТ: i (рядки), j (стовпці)
        for (int i = 0; i < model.Height; i++)
        {
            for (int j = 0; j < model.Width; j++)
            {
                // Доступ [i, j]
                int id = model.OccupiedGrid[i, j];
                output += (id == 0 ? "." : id.ToString()) + " ";
            }
            output += "\n";
        }
        Debug.Log(output);
    }
}
using System.Collections.Generic;
using UnityEngine;


public static class LevelLoader
{
    public static LevelModel LoadFromJSON(string jsonText)
    {
        if (string.IsNullOrEmpty(jsonText)) return null;

        LevelDataDTO dto = JsonUtility.FromJson<LevelDataDTO>(jsonText);

        LevelModel model = new LevelModel();
        model.Width = dto.width;
        model.Height = dto.height;

        // Ініціалізуємо як [Rows, Cols] -> [Height, Width]
        model.OccupiedGrid = new int[dto.height, dto.width];

        foreach (var arrowData in dto.arrows)
        {
            ArrowModel arrowModel = new ArrowModel();
            arrowModel.Id = arrowData.id;

            List<Vector2Int> points = new List<Vector2Int>();
            for (int k = 0; k < arrowData.cells.Length; k += 2)
            {
                if (k + 1 < arrowData.cells.Length)
                {
                    // JSON зазвичай зберігає [row, col] або [x, y], тут вважаємо що це [y, x] в масиві
                    // Але в коді було: arrowData.cells[i] це row, i+1 це col.
                    int y = arrowData.cells[k];     // Row
                    int x = arrowData.cells[k + 1]; // Col

                    points.Add(new Vector2Int(x, y));

                    if (x >= 0 && x < model.Width && y >= 0 && y < model.Height)
                    {
                        // Записуємо в [Row, Col] -> [y, x]
                        model.OccupiedGrid[y, x] = arrowData.id;
                    }
                }
            }

            if (points.Count > 0)
            {
                ArrowPoint first = new ArrowPoint { GridPosition = points[0] };
                ArrowPoint current = first;

                for (int i = 1; i < points.Count; i++)
                {
                    ArrowPoint nextP = new ArrowPoint { GridPosition = points[i] };
                    current.Next = nextP;
                    nextP.Prev = current;
                    current = nextP;
                }

                arrowModel.StartPoint = first;
                arrowModel.EndPoint = current;

                model.AddArrow(arrowModel);
            }
        }

        return model;
    }

    public static string SaveToJSON(LevelModel model)
    {
        LevelDataDTO dto = new LevelDataDTO();
        dto.width = model.Width;
        dto.height = model.Height;
        dto.arrows = new List<ArrowDataDTO>();

        foreach (var arrowModel in model.Arrows.Values)
        {
            ArrowDataDTO arrowDto = new ArrowDataDTO();
            arrowDto.id = arrowModel.Id;

            // Збираємо координати точок зі зв'язного списку
            List<int> cellsList = new List<int>();

            ArrowPoint current = arrowModel.StartPoint;
            while (current != null)
            {

                cellsList.Add(current.GridPosition.y); // Row
                cellsList.Add(current.GridPosition.x); // Col

                current = current.Next;
            }

            arrowDto.cells = cellsList.ToArray();

            // Напрямок вираховується при завантаженні, тому пишемо нуль (або можна вирахувати)
            arrowDto.direction = Vector2Int.zero;

            dto.arrows.Add(arrowDto);
        }

        // true робить JSON красивим (з відступами), щоб ти міг його читати очима
        return JsonUtility.ToJson(dto, true);
    }
}
using UnityEngine;
using UnityEngine.SceneManagement;
using options;

public class MainMenuController : MonoBehaviour
{
    public void OnPlayButtonClick()
    {
        
        SceneManager.LoadScene("Game");
    }
}
using UnityEngine;
using UnityEngine.EventSystems;


public class InputHandler : MonoBehaviour
{
    public event System.Action<GridCoordinate> OnGridClick;

    [SerializeField] private Camera _camera; // Можна призначити в інспекторі

    private bool _isInputActive = true; // Прапорець для блокування введення

    private void Awake()
    {
        // Якщо камеру не призначили в інспекторі, беремо головну
        if (_camera == null) _camera = Camera.main;
    }

    private void Update()
    {
        if (!_isInputActive) return;
        if (EventSystem.current != null && EventSystem.current.IsPointerOverGameObject()) return;

        if (Input.GetMouseButtonDown(0))
        {
            TryGetClickedCell(out var coord);
        }
    }

    public void SetInputActive(bool active)
    {
        _isInputActive = active;
    }

    private bool TryGetClickedCell(out GridCoordinate coord)
    {
        coord = default;
        Vector2 mousePos = _camera.ScreenToWorldPoint(Input.mousePosition);

        // ВАЖЛИВО: Переконайся, що на GridCell є BoxCollider2D
        RaycastHit2D hit = Physics2D.Raycast(mousePos, Vector2.zero);

        if (hit.collider != null)
        {
            var cell = hit.collider.GetComponent<GridCell>();
            if (cell != null)
            {
                // Створюємо координату (X = Column, Y = Row)
                coord = new GridCoordinate(cell.X, cell.Y);

                // Викликаємо подію!
                OnGridClick?.Invoke(coord);
                return true;
            }
        }
        return false;
    }
}

public struct GridCoordinate
{
    public int Column { get; private set; } // X
    public int Row { get; private set; }    // Y

    public GridCoordinate(int col, int row)
    {
        Column = col;
        Row = row;
    }

    public Vector2Int ToVector2Int() => new Vector2Int(Column, Row);

    public static GridCoordinate FromVector2Int(Vector2Int vector)
        => new GridCoordinate(vector.x, vector.y);
}
using ArrowPuzzle;
using System.Collections.Generic;
using UnityEngine;
using System.IO;

public class ArrowLevelManager : MonoBehaviour
{
    [Header("Налаштування генерації")]
    public int width = 6;  // Columns (j)
    public int height = 8; // Rows (i)
    public int minLength = 2;
    public int maxLength = 8;
    [Range(0f, 1f)] public float turnChance = 0.6f;

    [Header("Посилання")]
    [SerializeField] private LevelView _levelView;

    [Header("Налаштування камери")]
    [SerializeField] private Camera _camera; // Перетягніть сюди Main Camera
    [SerializeField] private float _padding = 1.5f; // Відступ від країв екрану

    [Header("Збереження")]
    public string saveFileName = "level_1";

    // ДОДАЙТЕ ЦЕ ПОСИЛАННЯ В ІНСПЕКТОРІ:
    [SerializeField] private GridView _gridView;

    private LevelModel _currentLevel;
    private LevelGenerator _generator;

    private void Awake()
    {
        if (_camera == null) _camera = Camera.main;
    }

    void Start()
    {
        _generator = new LevelGenerator();
    }

    [ContextMenu("Generate New Level")]
    public void Generate()
    {
        if (_levelView == null || _gridView == null)
        {
            Debug.LogError("ArrowLevelManager: Не призначено LevelView або GridView!");
            return;
        }

        // КРОК 1: Перебудовуємо візуальну сітку під нові розміри
        // (Rows = height, Cols = width)
        _gridView.Init(height, width);

        // КРОК 2: Генеруємо логіку рівня
        if (_generator == null) _generator = new LevelGenerator();
        _currentLevel = _generator.GenerateLevelModel(width, height, minLength, maxLength, turnChance);

        // КРОК 3: Малюємо стрілки
        _levelView.RenderLevel(_currentLevel);
        FitCameraToLevel();
        Debug.Log($"Рівень {_currentLevel.Width}x{_currentLevel.Height} згенеровано.");
    }

    // ... решта коду Update, ProcessClick, HandleCellClick ...
    // (вона залишається без змін, бо використовує _currentLevel, який ми щойно оновили)

    private void Update()
    {
        if (Input.GetMouseButtonDown(0)) ProcessClick();
        if (Input.GetKeyDown(KeyCode.S))
        {
            SaveCurrentLevel();
        }

        // НОВЕ: Натисни 'G', щоб згенерувати новий (для швидкого пошуку крутого рівня)
        if (Input.GetKeyDown(KeyCode.G))
        {
            Generate();
        }

        if (Input.GetKeyDown(KeyCode.C))
        {
            TrySolve();
        }


    }

    public void TrySolve()
    {
        
        while (_currentLevel.Arrows.Count != 0)
        {
            var arrowCount = _currentLevel.Arrows.Count;
            for (int i = 0; i < height; i++)
            {
                for(int j = 0; j < width; j++)
                {
                    HandleCellClick(i, j);
                }
            }
            if(arrowCount == _currentLevel.Arrows.Count)
            {
                Debug.Log("Рівень не розв'язується!");
                return;
            }
        }
    }

    public void SaveCurrentLevel()
    {
        if (_currentLevel == null)
        {
            Debug.LogError("Немає рівня для збереження!");
            return;
        }

        // 1. Конвертуємо рівень у текст JSON
        string json = LevelLoader.SaveToJSON(_currentLevel);

        // 2. Визначаємо шлях до папки Resources/Levels
        // Використовуємо Application.dataPath, щоб зберегти прямо в папку проекту Unity
        string path = Path.Combine(Application.dataPath, "Resources/Levels");

        // Створюємо папку, якщо її немає
        if (!Directory.Exists(path)) Directory.CreateDirectory(path);

        // 3. Формуємо повний шлях до файлу
        string fullPath = Path.Combine(path, saveFileName + ".json");

        // 4. Записуємо файл
        File.WriteAllText(fullPath, json);

        Debug.Log($"? Рівень збережено! Шлях: {fullPath}");

#if UNITY_EDITOR
        // Оновлюємо базу ассетів Unity, щоб файл одразу з'явився у вікні Project
        UnityEditor.AssetDatabase.Refresh();
#endif
    }

    private void ProcessClick()
    {
        if (_currentLevel == null) return;
        Vector2 mousePos = Camera.main.ScreenToWorldPoint(Input.mousePosition);
        RaycastHit2D hit = Physics2D.Raycast(mousePos, Vector2.zero);

        if (hit.collider != null)
        {
            var cell = hit.collider.GetComponent<GridCell>();
            if (cell != null)
            {
                HandleCellClick(cell.X, cell.Y);
            }
        }
    }

    private void HandleCellClick(int x, int y)
    {
        int arrowId = _currentLevel.GetArrowIdAt(x, y);
        if (arrowId <= 0) return;

        if (_currentLevel.CanArrowFlyAway(arrowId))
        {
            Debug.Log($"Стрілка {arrowId} полетіла!");
            _currentLevel.RemoveArrow(arrowId);
            _levelView.RemoveVisualArrow(arrowId);
            CheckWin();
        }
        else
        {
            Debug.Log($"Стрілка {arrowId} заблокована!");
        }
    }

    private void CheckWin()
    {
        if (_currentLevel.Arrows.Count == 0)
        {
            Debug.Log("Рівень пройдено!");
            // Invoke("Generate", 1f); // Авто-рестарт
        }
    }

    private void FitCameraToLevel()
    {
        if (_camera == null) return;

        float cellSize = _gridView.CellSize;
        Vector3 startPos = _gridView.StartPosition;

        // 1. Розрахунок розмірів сітки у світових одиницях
        float gridWorldWidth = width * cellSize;
        float gridWorldHeight = height * cellSize;

        // 2. Розрахунок центру сітки
        // X: зміщуємося від старту вправо на половину ширини, але враховуємо, що позиція клітинки - це її центр (або край, залежно від реалізації).
        // У вашому GridView позиція - це центр об'єкта.
        // Центр масиву точок: (Start + End) / 2
        // StartX (col 0) = startPos.x
        // EndX (col w-1) = startPos.x + (width - 1) * cellSize
        float centerX = startPos.x + (width - 1) * cellSize / 2.0f;
        float centerY = startPos.y - (height - 1) * cellSize / 2.0f; // Y йде вниз

        // Переміщуємо камеру в центр (зберігаємо Z)
        _camera.transform.position = new Vector3(centerX, centerY, _camera.transform.position.z);

        // 3. Розрахунок зуму (Orthographic Size)
        // OrthographicSize — це половина висоти екрану в одиницях Unity.

        // Потрібна висота + відступи
        float targetHeight = gridWorldHeight / 2.0f + _padding;

        // Потрібна ширина + відступи (переведена у висоту через Aspect Ratio)
        float aspect = _camera.aspect;
        float targetWidth = (gridWorldWidth / 2.0f + _padding) / aspect;

        // Вибираємо більше значення, щоб сітка влізла і по ширині, і по висоті
        _camera.orthographicSize = Mathf.Max(targetHeight, targetWidth);
    }
}
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace ArrowPuzzle
{
    [System.Serializable]
    public class SnakeData
    {
        public int id;
        public List<Vector2Int> cells;
        public Vector2Int direction;
        public bool removed = false;

        public SnakeData(int id, List<Vector2Int> cells)
        {
            this.id = id;
            this.cells = new List<Vector2Int>(cells);
            UpdateDirection();
        }

        public Vector2Int Head => cells[cells.Count - 1];
        public Vector2Int Tail => cells[0];

        public void UpdateDirection()
        {
            if (cells.Count < 2)
            {
                direction = Vector2Int.right;
                return;
            }
            Vector2Int head = cells[cells.Count - 1];
            Vector2Int neck = cells[cells.Count - 2];
            direction = head - neck;
        }

        public void Flip()
        {
            cells.Reverse();
            UpdateDirection();
        }
    }

    public class LevelGenerator
    {
        private int width;
        private int height;
        private int[,] grid;
        private List<GenSnake> snakes;
        private System.Random rng;

        public LevelGenerator(int seed = -1)
        {
            rng = seed == -1 ? new System.Random() : new System.Random(seed);
        }

        public LevelModel GenerateLevelModel(int w, int h, int minLen, int maxLen, float turnChance)
        {
            this.width = w;
            this.height = h;
            this.grid = new int[h, w];
            this.snakes = new List<GenSnake>();

            BuildLevelConstructive(minLen, maxLen, turnChance);
            FillGapsClean();

            // Багато спроб оптимізації
            int optimizeAttempts = 0;
            while (!IsLevelSolvable() && optimizeAttempts < 10)
            {
                OptimizeLevel();
                optimizeAttempts++;
            }

            LevelModel level = new LevelModel();
            level.Width = w;
            level.Height = h;
            level.OccupiedGrid = (int[,])grid.Clone();

            foreach (var snake in snakes)
            {
                ArrowModel arrow = new ArrowModel();
                arrow.Id = snake.id;

                ArrowPoint prevPoint = null;
                for (int k = 0; k < snake.cells.Count; k++)
                {
                    Vector2Int pos = snake.cells[k];
                    ArrowPoint p = new ArrowPoint { GridPosition = pos };

                    if (prevPoint != null)
                    {
                        prevPoint.Next = p;
                        p.Prev = prevPoint;
                    }

                    if (k == 0) arrow.StartPoint = p;
                    if (k == snake.cells.Count - 1) arrow.EndPoint = p;

                    prevPoint = p;
                }
                level.AddArrow(arrow);
            }

            return level;
        }

        private void BuildLevelConstructive(int minLen, int maxLen, float turnChance)
        {
            int snakeId = 1;
            int failures = 0;
            int maxFailures = 300;

            while (failures < maxFailures)
            {
                var emptyCells = new List<Vector2Int>();

                for (int i = 0; i < height; i++)
                {
                    for (int j = 0; j < width; j++)
                    {
                        if (grid[i, j] == 0)
                        {
                            emptyCells.Add(new Vector2Int(j, i));
                        }
                    }
                }

                if (emptyCells.Count == 0) break;

                Vector2Int start = emptyCells[rng.Next(emptyCells.Count)];
                GenSnake newSnake = CreateRandomSnake(start, minLen, maxLen, turnChance, snakeId);

                if (newSnake == null) { failures++; continue; }

                // Перевірка на самозациклення
                if (SnakeLooksAtItself(newSnake))
                {
                    failures++;
                    continue;
                }

                snakes.Add(newSnake);
                foreach (var c in newSnake.cells) grid[c.y, c.x] = newSnake.id;

                // Замість перевірки взаємних поглядів, перевіряємо розв'язуваність
                if (!IsLevelSolvable())
                {
                    foreach (var c in newSnake.cells) grid[c.y, c.x] = 0;
                    snakes.RemoveAt(snakes.Count - 1);
                    failures++;
                }
                else
                {
                    snakeId++;
                    failures = 0;
                }
            }
        }

        private bool SnakeLooksAtItself(GenSnake snake)
        {
            Vector2Int check = snake.Head + snake.direction;
            var cellSet = new HashSet<Vector2Int>(snake.cells);

            while (check.x >= 0 && check.x < width && check.y >= 0 && check.y < height)
            {
                if (cellSet.Contains(check))
                {
                    return true;
                }
                check += snake.direction;
            }
            return false;
        }

        private void FillGapsClean()
        {
            UpdateGridMap();
            bool changed = true;
            int iter = 0;
            while (changed && iter++ < 5)
            {
                changed = false;
                UpdateGridMap();
                var gaps = new List<Vector2Int>();

                for (int i = 0; i < height; i++)
                {
                    for (int j = 0; j < width; j++)
                    {
                        if (grid[i, j] == 0) gaps.Add(new Vector2Int(j, i));
                    }
                }

                gaps = gaps.OrderBy(a => rng.Next()).ToList();

                foreach (var gap in gaps)
                {
                    var neighbors = GetNeighbors(gap);
                    var candidates = new List<(GenSnake s, bool isHead)>();

                    foreach (var n in neighbors)
                    {
                        if (grid[n.y, n.x] != 0)
                        {
                            var s = snakes.Find(x => x.id == grid[n.y, n.x]);
                            if (s == null) continue;

                            bool isHead = (Mathf.Abs(s.Head.x - gap.x) + Mathf.Abs(s.Head.y - gap.y) == 1);
                            bool isTail = (Mathf.Abs(s.cells[0].x - gap.x) + Mathf.Abs(s.cells[0].y - gap.y) == 1);

                            if (isHead) candidates.Add((s, true));
                            else if (isTail) candidates.Add((s, false));
                        }
                    }

                    if (candidates.Count > 0)
                    {
                        var choice = candidates[rng.Next(candidates.Count)];
                        var oldCells = new List<Vector2Int>(choice.s.cells);

                        if (choice.isHead)
                        {
                            choice.s.cells.Add(gap);
                            choice.s.UpdateDirection();
                        }
                        else
                        {
                            choice.s.cells.Insert(0, gap);
                            choice.s.UpdateDirection();
                        }

                        // Перевіряємо тільки самозациклення та розв'язуваність
                        if (SnakeLooksAtItself(choice.s) || !IsLevelSolvable())
                        {
                            choice.s.cells = oldCells;
                            choice.s.UpdateDirection();
                        }
                        else
                        {
                            grid[gap.y, gap.x] = choice.s.id;
                            changed = true;
                        }
                    }
                }
            }
        }

        private GenSnake CreateRandomSnake(Vector2Int start, int minLen, int maxLen, float turnChance, int id)
        {
            var cells = new List<Vector2Int> { start };
            Vector2Int curr = start;
            int targetLen = rng.Next(minLen, maxLen + 1);
            Vector2Int? lastDir = null;
            var used = new HashSet<Vector2Int> { start };

            for (int k = 0; k < targetLen - 1; k++)
            {
                var neighbors = GetNeighbors(curr)
                    .Where(n => grid[n.y, n.x] == 0 && !used.Contains(n))
                    .ToList();

                if (neighbors.Count == 0) break;

                Vector2Int next;
                Vector2Int? straight = null;
                if (lastDir.HasValue)
                {
                    Vector2Int s = curr + lastDir.Value;
                    if (neighbors.Contains(s)) straight = s;
                }

                if (rng.NextDouble() < turnChance || straight == null)
                    next = neighbors[rng.Next(neighbors.Count)];
                else
                    next = straight.Value;

                cells.Add(next);
                used.Add(next);
                lastDir = next - curr;
                curr = next;
            }

            if (cells.Count < minLen) return null;

            // Вибираємо орієнтацію, щоб голова була ближче до краю
            Vector2Int head = cells[cells.Count - 1];
            Vector2Int tail = cells[0];
            int dHead = Mathf.Min(Mathf.Min(head.x, width - 1 - head.x), Mathf.Min(head.y, height - 1 - head.y));
            int dTail = Mathf.Min(Mathf.Min(tail.x, width - 1 - tail.x), Mathf.Min(tail.y, height - 1 - tail.y));

            if (dTail < dHead && rng.NextDouble() > 0.3)
                cells.Reverse();

            return new GenSnake(id, cells);
        }

        private bool IsLevelSolvable()
        {
            int[,] simGrid = (int[,])grid.Clone();
            var active = new List<GenSnake>();

            // Створюємо копії змійок для симуляції
            foreach (var s in snakes)
            {
                active.Add(new GenSnake(s.id, s.cells));
            }

            bool progress = true;
            int maxIterations = 100;
            int iterations = 0;

            while (progress && active.Count > 0 && iterations < maxIterations)
            {
                progress = false;
                var next = new List<GenSnake>();

                foreach (var s in active)
                {
                    if (CanSnakeFly(s, simGrid))
                    {
                        foreach (var c in s.cells)
                            simGrid[c.y, c.x] = 0;
                        progress = true;
                    }
                    else
                    {
                        next.Add(s);
                    }
                }

                active = next;
                iterations++;
            }

            return active.Count == 0;
        }

        private bool CanSnakeFly(GenSnake snake, int[,] currentGrid)
        {
            Vector2Int check = snake.Head + snake.direction;

            while (check.x >= 0 && check.x < width && check.y >= 0 && check.y < height)
            {
                if (currentGrid[check.y, check.x] != 0)
                    return false;
                check += snake.direction;
            }

            return true;
        }

        private void OptimizeLevel()
        {
            // Багато спроб flip для різних змійок
            for (int attempt = 0; attempt < 1000; attempt++)
            {
                if (snakes.Count == 0) break;

                var snake = snakes[rng.Next(snakes.Count)];
                var oldCells = new List<Vector2Int>(snake.cells);

                snake.Flip();
                UpdateGridMap();

                // Якщо після flip рівень розв'язний або краще - залишаємо
                if (!SnakeLooksAtItself(snake) && IsLevelSolvable())
                {
                    return; // Знайшли розв'язок
                }

                // Інакше відкат
                snake.cells = oldCells;
                snake.UpdateDirection();
                UpdateGridMap();
            }

            // Якщо flip не допоміг, пробуємо видалити найпроблемнішу змійку
            if (!IsLevelSolvable() && snakes.Count > 0)
            {
                var worstSnake = FindMostBlockingSnake();
                if (worstSnake != null)
                {
                    foreach (var c in worstSnake.cells)
                        grid[c.y, c.x] = 0;
                    snakes.Remove(worstSnake);
                    UpdateGridMap();
                }
            }
        }

        private GenSnake FindMostBlockingSnake()
        {
            // Знаходимо змійку, яка блокує найбільше інших
            var blockCounts = new Dictionary<int, int>();

            foreach (var snake in snakes)
            {
                blockCounts[snake.id] = 0;
            }

            foreach (var snake in snakes)
            {
                Vector2Int check = snake.Head + snake.direction;

                while (check.x >= 0 && check.x < width && check.y >= 0 && check.y < height)
                {
                    int cellId = grid[check.y, check.x];
                    if (cellId != 0 && cellId != snake.id)
                    {
                        blockCounts[cellId]++;
                        break;
                    }
                    check += snake.direction;
                }
            }

            int maxBlocks = blockCounts.Values.Max();
            if (maxBlocks == 0) return snakes[rng.Next(snakes.Count)];

            var mostBlocked = blockCounts.Where(kv => kv.Value == maxBlocks).Select(kv => kv.Key).ToList();
            int targetId = mostBlocked[rng.Next(mostBlocked.Count)];

            return snakes.Find(s => s.id == targetId);
        }

        private void UpdateGridMap()
        {
            grid = new int[height, width];
            foreach (var s in snakes)
                foreach (var c in s.cells)
                    grid[c.y, c.x] = s.id;
        }

        private List<Vector2Int> GetNeighbors(Vector2Int p)
        {
            var res = new List<Vector2Int>();
            if (p.x > 0) res.Add(new Vector2Int(p.x - 1, p.y));
            if (p.x < width - 1) res.Add(new Vector2Int(p.x + 1, p.y));
            if (p.y > 0) res.Add(new Vector2Int(p.x, p.y - 1));
            if (p.y < height - 1) res.Add(new Vector2Int(p.x, p.y + 1));
            return res;
        }
    }

    public class GenSnake
    {
        public int id;
        public List<Vector2Int> cells;
        public Vector2Int direction;

        public GenSnake(int id, List<Vector2Int> cells)
        {
            this.id = id;
            this.cells = new List<Vector2Int>(cells);
            UpdateDirection();
        }

        public Vector2Int Head => cells[cells.Count - 1];

        public void UpdateDirection()
        {
            if (cells.Count < 2)
            {
                direction = Vector2Int.right;
                return;
            }
            direction = cells[cells.Count - 1] - cells[cells.Count - 2];
        }

        public void Flip()
        {
            cells.Reverse();
            UpdateDirection();
        }
    }
}
using UnityEngine;
// 2. Клас, що описує одну стрілку (Логічна сутність)
public class ArrowModel
{
    public int Id;
    public ArrowPoint StartPoint; // Голова списку
    public ArrowPoint EndPoint;   // Хвіст списку (там, де малюється стрілка)
    public Color Color = Color.white; // Можна додати властивості, які впливають на геймплей
}
using System.Collections.Generic;
using UnityEngine;

public class LevelModel
{
    public int Width;  // Кількість стовпців (Columns)
    public int Height; // Кількість рядків (Rows)

    // Зберігаємо як [Row, Col] -> [i, j] -> [y, x]
    public int[,] OccupiedGrid;

    public Dictionary<int, ArrowModel> Arrows = new Dictionary<int, ArrowModel>();

    public void AddArrow(ArrowModel arrow)
    {
        if (!Arrows.ContainsKey(arrow.Id))
        {
            Arrows.Add(arrow.Id, arrow);
        }
    }

    public bool CanArrowFlyAway(int arrowId)
    {
        if (!Arrows.TryGetValue(arrowId, out ArrowModel arrow)) return false;

        Vector2Int headPos = arrow.EndPoint.GridPosition;
        Vector2Int prevPos = arrow.EndPoint.Prev.GridPosition;
        Vector2Int direction = headPos - prevPos;

        Vector2Int checkPos = headPos + direction;

        while (IsInsideGrid(checkPos))
        {
            // Звертаємось: [y, x] (тому що Grid[Row, Col])
            int cellValue = OccupiedGrid[checkPos.y, checkPos.x];

            if (cellValue > 0) return false;

            checkPos += direction;
        }

        return true;
    }

    public void RemoveArrow(int arrowId)
    {
        if (!Arrows.TryGetValue(arrowId, out ArrowModel arrow)) return;

        ArrowPoint current = arrow.StartPoint;
        while (current != null)
        {
            // Очищаємо: [y, x]
            OccupiedGrid[current.GridPosition.y, current.GridPosition.x] = 0;
            current = current.Next;
        }

        Arrows.Remove(arrowId);
    }

    public bool IsInsideGrid(Vector2Int pos)
    {
        // X - це стовпець (0..Width-1), Y - це рядок (0..Height-1)
        return pos.x >= 0 && pos.x < Width && pos.y >= 0 && pos.y < Height;
    }

    public int GetArrowIdAt(int x, int y)
    {
        if (IsInsideGrid(new Vector2Int(x, y)))
        {
            // Повертаємо значення з рядка Y, стовпця X
            return OccupiedGrid[y, x];
        }
        return -1;
    }
}
using UnityEngine;
// 1. Клас, що описує одну точку в ланцюжку (Linked List)
public class ArrowPoint
{
    public Vector2Int GridPosition; // Координата на сітці [x,y]
    public ArrowPoint Prev;         // Посилання на попередню точку
    public ArrowPoint Next;         // Посилання на наступну точку
}
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// 4. DTO (Data Transfer Objects) - чисто для читання JSON
// (Unity JsonUtility не вміє читати складні структури, тому потрібні прості класи-посередники)
[System.Serializable]
public class LevelDataDTO
{
    public int width;
    public int height;
    public List<ArrowDataDTO> arrows;
}

[System.Serializable]
public class ArrowDataDTO
{
    public int id;
    public int[] cells; // Плоский масив [x,y,x,y...]
    public Vector2Int direction; // Поки не використовуємо, бо вираховуємо математично, але хай буде
}

public class ArrowPath
{
    public ArrowPoint startPoint;
    public ArrowPoint endPoint;
}
using UnityEngine;

[RequireComponent(typeof(BoxCollider2D))]
public class GridCell : MonoBehaviour
{
    public int X { get; private set; }
    public int Y { get; private set; }

    // Убрали manager, оставили только координаты и размер
    public void Init(int x, int y, float size)
    {
        X = x;
        Y = y;

        // Настраиваем размер колайдера
        var collider = GetComponent<BoxCollider2D>();
        if (collider != null)
        {
            collider.size = new Vector2(size, size);
        }
    }
}
using UnityEngine;

public class GridView : MonoBehaviour
{
    [SerializeField] private int _rows = 5;
    [SerializeField] private int _columns = 5;

    [SerializeField] private float _cellSize = 1.0f;
    [SerializeField] private Transform _startPosition;
    [SerializeField] private GameObject _cellPrefab;

    private Vector2[,] _pointPositions;
    public Vector2[,] PointPositions => _pointPositions;
    public float CellSize => _cellSize;
    public Vector3 StartPosition => _startPosition != null ? _startPosition.position : transform.position;



    public void Init(int rows, int cols)
    {
        _rows = rows;
        _columns = cols;

        for (int k = transform.childCount - 1; k >= 0; k--)
        {
            GameObject child = transform.GetChild(k).gameObject;

#if UNITY_EDITOR
            if (!Application.isPlaying) DestroyImmediate(child);
            else Destroy(child);
#else
            Destroy(child);
#endif
        }

        // 2. Створення нового масиву
        _pointPositions = new Vector2[_rows, _columns];

        // 3. Генерація нових клітинок
        // i = Рядок (Row / Y), j = Стовпець (Col / X)
        for (int i = 0; i < _rows; i++)
        {
            for (int j = 0; j < _columns; j++)
            {
                var cell = Instantiate(_cellPrefab, transform);

                // Передаємо логічні (X=j, Y=i)
                cell.GetComponent<GridCell>().Init(j, i, _cellSize);

                // Розрахунок позиції у світі
                cell.transform.position = new Vector3(
                    _startPosition.position.x + j * _cellSize,
                    _startPosition.position.y - i * _cellSize,
                    _startPosition.position.z
                );

                // Зберігаємо в [Row, Col] -> [i, j]
                _pointPositions[i, j] = new Vector2(cell.transform.position.x, cell.transform.position.y);
            }
        }
    }
}
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class LevelView : MonoBehaviour
{
    [Header("Налаштування")]
    [SerializeField] private GridView _gridView;
    [SerializeField] private GameObject _arrowPrefab;
    [SerializeField] private GameObject _headPrefab;

    [Header("Анімація")]
    [SerializeField] private float _snakeSpeed = 5f; // Швидкість уползання
    [SerializeField] private float _offScreenDistance = 10f; // Наскільки далеко повзти за межі

    // Зберігаємо не тільки об'єкт, а й його голову та оригінальний шлях
    private class ArrowVisualData
    {
        public GameObject RootObject;
        public LineRenderer LineRenderer;
        public Transform HeadTransform;
        public List<Vector3> FullPath; // Шлях у світових координатах
    }

    private Dictionary<int, ArrowVisualData> _visualArrows = new Dictionary<int, ArrowVisualData>();

    public void ClearView()
    {
        StopAllCoroutines(); // Зупиняємо анімації, якщо вони йдуть
        foreach (var data in _visualArrows.Values)
        {
            if (data.RootObject != null) Destroy(data.RootObject);
        }
        _visualArrows.Clear();
    }

    // Додаємо параметр animate = true за замовчуванням
    public void RemoveVisualArrow(int arrowId, bool animate = true, float speed = 45f)
    {
        if (_visualArrows.TryGetValue(arrowId, out ArrowVisualData data))
        {
            _visualArrows.Remove(arrowId); // Видаляємо логічно

            if (animate && gameObject.activeInHierarchy)
            {
                // Визначаємо, яку швидкість використовувати
                float effectiveSpeed = (speed > 0) ? speed : _snakeSpeed;

                StartCoroutine(SnakeExitRoutine(data, effectiveSpeed, () =>
                {
                    if (data.RootObject != null) Destroy(data.RootObject);
                }));
            }
            else
            {
                if (data.RootObject != null) Destroy(data.RootObject);
            }
        }
    }

    public void RenderLevel(LevelModel level)
    {
        ClearView();
        foreach (var arrowModel in level.Arrows.Values)
        {
            RenderArrow(arrowModel);
        }
    }



    private void RenderArrow(ArrowModel arrow)
    {
        GameObject lineObj = Instantiate(_arrowPrefab, transform);
        lineObj.name = $"Visual_Arrow_{arrow.Id}";

        LineRenderer lr = lineObj.GetComponent<LineRenderer>();

        // Будуємо шлях
        List<Vector3> worldPositions = new List<Vector3>();
        ArrowPoint current = arrow.StartPoint;
        worldPositions.Add(GridToWorld(current.GridPosition));

        while (current.Next != null)
        {
            AddIntermediatePoints(worldPositions, current.GridPosition, current.Next.GridPosition);
            current = current.Next;
        }

        // Застосовуємо точки
        lr.positionCount = worldPositions.Count;
        lr.SetPositions(worldPositions.ToArray());

        // Створюємо голову
        GameObject headObj = RenderHead(arrow, lineObj.transform);

        // Зберігаємо дані для майбутньої анімації
        ArrowVisualData visualData = new ArrowVisualData
        {
            RootObject = lineObj,
            LineRenderer = lr,
            HeadTransform = headObj.transform,
            FullPath = new List<Vector3>(worldPositions) // Копіюємо список
        };

        _visualArrows.Add(arrow.Id, visualData);
    }

    private GameObject RenderHead(ArrowModel arrow, Transform parent)
    {
        if (arrow.EndPoint == null || arrow.EndPoint.Prev == null) return null;

        Vector3 endPos = GridToWorld(arrow.EndPoint.GridPosition);
        Vector3 prevPos = GridToWorld(arrow.EndPoint.Prev.GridPosition);
        Vector3 dir = (endPos - prevPos).normalized;

        // Визначаємо кут (твоя логіка)
        float zAngle = 0f;
        if (Mathf.Abs(dir.x) > Mathf.Abs(dir.y)) zAngle = (dir.x > 0) ? -90f : -270f;
        else zAngle = (dir.y > 0) ? 0f : 180f;

        Quaternion rotation = Quaternion.Euler(0, 0, zAngle);
        return Instantiate(_headPrefab, endPos, rotation, parent);
    }

    // -----------------------------------------------------------------------
    // ЛОГІКА АНІМАЦІЇ (ЗМІЙКА)
    // -----------------------------------------------------------------------
    private IEnumerator SnakeExitRoutine(ArrowVisualData data, float speed, System.Action onComplete)
    {
        // ... (підготовка шляху, так само як було) ...
        List<Vector3> extendedPath = new List<Vector3>(data.FullPath);
        if (extendedPath.Count >= 2)
        {
            Vector3 last = extendedPath[extendedPath.Count - 1];
            Vector3 prev = extendedPath[extendedPath.Count - 2];
            Vector3 dir = (last - prev).normalized;
            extendedPath.Add(last + dir * _offScreenDistance);
        }

        float snakeLength = GetPathLength(data.FullPath);
        float totalDist = snakeLength + _offScreenDistance;
        float currentDist = 0f;

        while (currentDist < totalDist)
        {
            // ВИКОРИСТОВУЄМО ПЕРЕДАНУ ШВИДКІСТЬ 'speed' ЗАМІСТЬ '_snakeSpeed'
            currentDist += Time.deltaTime * speed;

            float tail = currentDist;
            float head = currentDist + snakeLength;

            UpdateLineRendererByPath(data.LineRenderer, extendedPath, tail, head);

            if (head < GetPathLength(extendedPath))
            {
                UpdateHeadPosition(data.HeadTransform, extendedPath, head);
            }
            else
            {
                data.HeadTransform.gameObject.SetActive(false);
            }

            yield return null;
        }

        onComplete?.Invoke();
    }

    // Бере шматок шляху і записує його в LineRenderer
    private void UpdateLineRendererByPath(LineRenderer lr, List<Vector3> path, float startDist, float endDist)
    {
        List<Vector3> newPositions = new List<Vector3>();
        float traveled = 0f;

        // Знаходимо точку початку (Хвіст)
        newPositions.Add(GetPointOnPath(path, startDist));

        // Додаємо всі проміжні точки шляху, які потрапляють у діапазон
        for (int i = 0; i < path.Count - 1; i++)
        {
            float segLen = Vector3.Distance(path[i], path[i + 1]);

            // Якщо кінець сегмента знаходиться далі хвоста, і початок сегмента раніше голови
            if (traveled + segLen > startDist && traveled < endDist)
            {
                // Додаємо вершину path[i+1], якщо вона всередині нашої змійки
                if (traveled + segLen < endDist)
                {
                    newPositions.Add(path[i + 1]);
                }
            }
            traveled += segLen;
        }

        // Знаходимо точку кінця (Голова) - вона ж остання точка лінії
        // (Але малюємо лінію трохи коротшою, щоб вона не вилазила з-під спрайта голови, якщо треба)
        newPositions.Add(GetPointOnPath(path, endDist));

        lr.positionCount = newPositions.Count;
        lr.SetPositions(newPositions.ToArray());
    }

    private void UpdateHeadPosition(Transform head, List<Vector3> path, float distance)
    {
        // Позиція
        Vector3 pos = GetPointOnPath(path, distance);
        head.position = pos;

        // Поворот (дивимось трохи вперед по шляху, щоб знати куди повертати)
        Vector3 lookAheadPos = GetPointOnPath(path, distance + 0.1f);
        Vector3 dir = (lookAheadPos - pos).normalized;

        if (dir != Vector3.zero)
        {
            float angle = Mathf.Atan2(dir.y, dir.x) * Mathf.Rad2Deg;
            // Корекція кута залежно від орієнтації спрайта (зазвичай -90 або +90)
            // Тут використовуємо твою логіку орієнтації, або просто поворот по Z
            head.rotation = Quaternion.Euler(0, 0, angle - 90); // -90 якщо спрайт стрілки дивиться вгору
        }
    }

    // Математика: Отримати точку на ламаній лінії за дистанцією від початку
    private Vector3 GetPointOnPath(List<Vector3> path, float distance)
    {
        if (distance <= 0) return path[0];

        float currentDist = 0f;
        for (int i = 0; i < path.Count - 1; i++)
        {
            float segLen = Vector3.Distance(path[i], path[i + 1]);
            if (currentDist + segLen >= distance)
            {
                float t = (distance - currentDist) / segLen;
                return Vector3.Lerp(path[i], path[i + 1], t);
            }
            currentDist += segLen;
        }
        return path[path.Count - 1]; // Якщо дистанція більша за шлях
    }

    private float GetPathLength(List<Vector3> path)
    {
        float dist = 0f;
        for (int i = 0; i < path.Count - 1; i++)
        {
            dist += Vector3.Distance(path[i], path[i + 1]);
        }
        return dist;
    }

    // -----------------------------------------------------------------------

    private void AddIntermediatePoints(List<Vector3> positions, Vector2Int from, Vector2Int to)
    {
        Vector2 dir = to - from;
        int steps = (int)(Mathf.Abs(dir.x) + Mathf.Abs(dir.y));
        if (steps > 0)
        {
            for (int i = 1; i <= steps; i++)
            {
                Vector2 stepPos = (Vector2)from + dir * i / steps;
                positions.Add(GridToWorld(stepPos));
            }
        }
    }

    private Vector3 GridToWorld(Vector2 gridPos)
    {
        if (_gridView != null && _gridView.PointPositions != null)
        {
            int x = (int)gridPos.x;
            int y = (int)gridPos.y;
            if (y >= 0 && y < _gridView.PointPositions.GetLength(0) &&
                x >= 0 && x < _gridView.PointPositions.GetLength(1))
            {
                Vector2 worldPos = _gridView.PointPositions[y, x];
                return new Vector3(worldPos.x, worldPos.y, 0);
            }
        }
        return Vector3.zero;
    }
}
